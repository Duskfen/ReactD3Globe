{"version":3,"sources":["components/Globe.js","App.js","reportWebVitals.js","index.js"],"names":["Globe","props","createTranslucentGlobe","canvas","d3","append","attr","width","height","canvasContext","node","getContext","_groups","projection","rotate","precision","fitSize","sphere","path","scale","call","zoom","on","renderWorld","GeoData","initializeSVG","svg","updatePointsOnGlobe","selectAll","point","isPointVisible","renderNewPointOnGlobe","circle","data","animate","r","duration","easing","onfinish","remove","randomIntFromInterval","min","max","Math","floor","random","randomPointSpawning","createRandomPoint","setTimeout","windowResizeEventHandler","globe","document","querySelector","dimensionsPerPropsSpecified","clientWidth","clientHeight","type","world","context","clearRect","lineWidth","beginPath","this","fillStyle","fill","stroke","strokeStyle","reflectX","visible","stream","x","y","v0","q0","r0","a0","tl","undefined","_scale","scaleExtent","map","zoomstarted","zoomed","event","that","t","length","atan2","p","versor","cartesian","invert","transform","k","pt","v1","delta","q1","multiply","d","s","sin","c","sign","cos","sqrt","rotation","Object","assign","selection","property","options","id","window","addEventListener","Component","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7d9a83b2.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport * as d3 from 'd3'\r\nimport GeoData from \"./geoJson/rough.geo.json\"\r\nimport versor from \"versor\" //versor is used for rotating the globe \r\n\r\n//maybe change to configurable variable if needed\r\nconst animationSpeed = 6000;\r\n\r\n// if you wonder why I render the world in canvas and the datapoints in svg:\r\n// -> It's because of the animations. I don't know how to animate in canvas.. \r\n// -> so I use svg with Element.animate() javascript function which lets me use\r\n//    css animations (-> good performance)\r\n\r\nexport default class Globe extends Component {\r\n   constructor(props) {\r\n      super(props);\r\n\r\n      this.dimensionsPerPropsSpecified = this.props.width && this.props.height;\r\n\r\n      this.width = this.props.width;\r\n      this.height = this.props.height;\r\n\r\n      this.sphere = ({ type: \"Sphere\" })\r\n      this.projection = null;\r\n      this.svg = null;\r\n   }\r\n \r\n   createTranslucentGlobe = () => {\r\n      let canvas = d3.select(\"#globe\")\r\n         .append(\"canvas\")\r\n         .attr(\"width\", this.width)\r\n         .attr('height', this.height)\r\n\r\n      let canvasContext = canvas\r\n         .node().getContext(\"2d\");\r\n\r\n      canvas = canvas._groups[0][0]\r\n\r\n      this.projection = d3.geoOrthographic()\r\n         .rotate([-10, -50])\r\n         .precision(0.1)\r\n         .fitSize([this.width, this.height], this.sphere)\r\n\r\n\r\n      let path = d3.geoPath(this.projection, canvasContext);\r\n\r\n      this.projection.scale(600)\r\n      return d3.select(canvasContext.canvas)\r\n         .call(this.zoom(this.projection)\r\n            .on(\"zoom.render\", () => this.renderWorld(GeoData, canvasContext, path, canvas)) //only a rough map while zooming/rotating (speed reasons)\r\n            .on(\"end.render\", () => this.renderWorld(GeoData, canvasContext, path, canvas))) //could specify a more detailed world\r\n         .call(() => this.renderWorld(GeoData, canvasContext, path, canvas)) //could specify a more detailed world\r\n         .node();\r\n   }\r\n\r\n   initializeSVG = () => {\r\n      //svg is for the globepoints\r\n      this.svg = d3.select(\"#globepoints\").append(\"svg\")\r\n         .attr(\"width\", this.width)\r\n         .attr('height', this.height);\r\n   }\r\n\r\n   renderWorld(world, context, path, canvas) {\r\n      //clear canvas\r\n      context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      context.lineWidth = 0.3;\r\n      context.beginPath();\r\n      path(this.sphere);\r\n      context.fillStyle = \"#fff\";\r\n      context.fill();\r\n      context.stroke()\r\n      context.strokeStyle = \"#E5E5E5\";\r\n\r\n      //translucent part (by \"fil\" -> https://observablehq.com/@d3/projection-reflectx) \r\n      const r = this.projection.rotate();\r\n      this.projection.reflectX(true).rotate([r[0] + 180, -r[1], -r[2]]);\r\n      context.beginPath();\r\n      path(world);\r\n      context.fillStyle = \"rgba(0,0,0,0.1)\";\r\n      context.fill();\r\n      this.projection.reflectX(false).rotate(r);\r\n\r\n      //countries, stroke are the white gaps between them\r\n      context.beginPath();\r\n      path(world);\r\n      context.fillStyle = \"rgba(0,0,0,1)\";\r\n      context.fill();\r\n      context.stroke()\r\n      context.strokeStyle = \"white\";\r\n\r\n      // if you want to render the datapoints via canvas\r\n      // context.beginPath(); //elements are now rendered with svg, to support better animations;\r\n      // path.pointRadius([3])\r\n      // path({type: \"MultiPoint\", coordinates:points});\r\n      // context.fillStyle=\"tomato\"\r\n      // context.fill();\r\n\r\n      this.updatePointsOnGlobe();\r\n\r\n      context.beginPath();\r\n      path(this.sphere);\r\n   }\r\n\r\n   updatePointsOnGlobe = () => {\r\n\r\n      //select all existing circles and update their coordinates\r\n      //if they are not visible on the earth (on the backside), change their opacity to 0\r\n\r\n      let circles = this.svg.selectAll(\"circle\");\r\n      circles\r\n         .attr(\"cx\", (point) => this.projection(point)[0])\r\n         .attr(\"cy\", (point) => this.projection(point)[1])\r\n         .attr(\"opacity\", (point) => {\r\n            if(this.isPointVisible(this.projection)(point))return 1\r\n            else return 0;\r\n         });\r\n   }\r\n\r\n   renderNewPointOnGlobe = (point) => {\r\n\r\n      let circle = this.svg.append(\"circle\") \r\n      .data([point])\r\n      .attr(\"class\", \"globepoint\")\r\n      .attr('r', 2)\r\n      .attr(\"cx\", (point) => this.projection(point)[0])\r\n      .attr(\"cy\", (point) => this.projection(point)[1])\r\n      .attr(\"data\", point).node()\r\n\r\n      let anim = circle.animate([\r\n         {r:\"0px\"},\r\n         {r:\"10px\"},\r\n         {r:\"0px\"},\r\n      ], {duration: animationSpeed, easing: \"ease-in-out\"})\r\n\r\n      //Attention, if you wan't to remove points manually (after a specific time, uncomment following line)\r\n      anim.onfinish = () => circle.remove();\r\n   }\r\n\r\n   // -------------------------- temporary (remove if real datapoints are implemented) --------------------------\r\n   //min and max are included\r\n   randomIntFromInterval = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\r\n   createRandomPoint(){\r\n      //longitude -180 to 180\r\n      //latitude 0 to 90\r\n      return [this.randomIntFromInterval(-180, 180), this.randomIntFromInterval(0, 90)]\r\n\r\n   }\r\n   randomPointSpawning = () => {\r\n      this.renderNewPointOnGlobe(this.createRandomPoint());\r\n      setTimeout(this.randomPointSpawning, this.randomIntFromInterval(10, 90))\r\n   }\r\n   // -------------------------- end temporary ------------------------------------------------------------------\r\n\r\n   isPointVisible(projection) {\r\n      let visible;\r\n      const stream = projection.stream({ point() { visible = true; } });\r\n\r\n      //visible is set to false;\r\n      // if a point is outside the stream, don't set visible to true, \r\n      // else set visible to true, return visible\r\n      return ([x, y]) => (visible = false, stream.point(x, y), visible);\r\n   }\r\n\r\n   // zoom by \"Fil\" -> https://observablehq.com/d/1ea380bf05fbf68c@322\r\n   zoom(projection, {\r\n      // Capture the projection’s original scale, before any zooming.\r\n      scale = projection._scale === undefined\r\n         ? (projection._scale = projection.scale())\r\n         : projection._scale,\r\n      scaleExtent = [0.04, 20]\r\n   } = {}) {\r\n      let v0, q0, r0, a0, tl;\r\n\r\n      const zoom = d3.zoom()\r\n         .scaleExtent(scaleExtent.map(x => x * scale))\r\n         .on(\"start\", zoomstarted)\r\n         .on(\"zoom\", zoomed);\r\n\r\n      function point(event, that) {\r\n         const t = d3.pointers(event, that);\r\n\r\n         if (t.length !== tl) {\r\n            tl = t.length;\r\n            if (tl > 1) a0 = Math.atan2(t[1][1] - t[0][1], t[1][0] - t[0][0]);\r\n            zoomstarted.call(that, event);\r\n         }\r\n\r\n         return tl > 1\r\n            ? [\r\n               d3.mean(t, p => p[0]),\r\n               d3.mean(t, p => p[1]),\r\n               Math.atan2(t[1][1] - t[0][1], t[1][0] - t[0][0])\r\n            ]\r\n            : t[0];\r\n      }\r\n\r\n      function zoomstarted(event) {\r\n         if (!event) return;\r\n         v0 = versor.cartesian(projection.invert(point(event, this)));\r\n         q0 = versor((r0 = projection.rotate()));\r\n      }\r\n\r\n      function zoomed(event) {\r\n         projection.scale(event.transform.k);\r\n         const pt = point(event, this);\r\n         const v1 = versor.cartesian(projection.rotate(r0).invert(pt));\r\n         const delta = versor.delta(v0, v1);\r\n         let q1 = versor.multiply(q0, delta);\r\n\r\n         // For multitouch, compose with a rotation around the axis.\r\n         if (pt[2]) {\r\n            const d = (pt[2] - a0) / 2;\r\n            const s = -Math.sin(d);\r\n            const c = Math.sign(Math.cos(d));\r\n            q1 = versor.multiply([Math.sqrt(1 - s * s), 0, 0, c * s], q1);\r\n         }\r\n\r\n         projection.rotate(versor.rotation(q1));\r\n\r\n         // In vicinity of the antipode (unstable) of q0, restart.\r\n         if (delta[0] < 0.7) zoomstarted.call(this);\r\n      }\r\n\r\n      return Object.assign(selection => selection\r\n         .property(\"__zoom\", d3.zoomIdentity.scale(projection.scale()))\r\n         .call(zoom), {\r\n         on(type, ...options) {\r\n            return options.length\r\n               ? (zoom.on(type, ...options), this)\r\n               : zoom.on(type);\r\n         }\r\n      });\r\n   }\r\n\r\n   render() {\r\n      return (\r\n         <>\r\n            <div id=\"globe\">\r\n            </div>\r\n            <div id=\"globepoints\">\r\n            </div>\r\n         </>\r\n      )\r\n   }\r\n\r\n   componentDidMount() {\r\n      let globe = document.querySelector(\"#globe\")\r\n\r\n      if(!this.dimensionsPerPropsSpecified){\r\n         this.width = globe.clientWidth; //set width to globe width (currently 100vw 100vh)\r\n         this.height = globe.clientHeight; //note: the globe width also applies to the globepoints\r\n      }\r\n\r\n      this.initializeSVG();\r\n      this.createTranslucentGlobe();\r\n\r\n      this.randomPointSpawning(); //TODO work with real data and not random points\r\n                                  //API polling? or Sockets? (sockets are a bit of a overhead i guess but idk..)\r\n\r\n      window.addEventListener(\"resize\", this.windowResizeEventHandler);\r\n   }\r\n\r\n   windowResizeEventHandler = () => {\r\n      //if resized, update the dimensions of the canvas and svg (all points get removed :( ))\r\n      // future: maybe just update the width and height properties so you don't have to rerender and the points doesn't get deleted\r\n      let globe = document.querySelector(\"#globe canvas\")\r\n      let svg = document.querySelector(\"#globepoints svg\")\r\n\r\n      if(!this.dimensionsPerPropsSpecified){\r\n         this.width = globe.clientWidth;\r\n         this.height = globe.clientHeight;\r\n      }\r\n      svg.remove()\r\n      globe.remove()\r\n      this.createTranslucentGlobe();\r\n      this.initializeSVG();\r\n   }\r\n}\r\n","import './App.css';\nimport Globe from './components/Globe'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n         Prototyp For React Globe\n      </header>\n      <main>\n         <Globe></Globe>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}